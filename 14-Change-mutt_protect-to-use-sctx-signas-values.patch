From 093cc268e9e812ca647f6edfcf8028dff9b62650 Mon Sep 17 00:00:00 2001
From: Kevin McCarthy <kevin@8t8.us>
Date: Fri, 31 Jan 2020 15:06:20 -0800
Subject: Change mutt_protect() to use sctx signas values

Pass the sctx into postpone_message() and save_fcc() to it can be
passed to mutt_protect.

Change compose menu to show the sctx values, but fall back to the
globals.

Upstream-commit: https://gitlab.com/muttmua/mutt/commit/093cc268e9e812ca647f6edfcf8028dff9b62650
Co-authored-by: Richard Russon <rich@flatcap.org>
---
 compose.c    | 10 ++++----
 ncrypt/crypt.c      | 64 ++++++++++++++++++++++++++++++++++++++++------------
 ncrypt/crypt.h |  2 +-
 send.c       | 32 ++++++++++++++++++--------
 4 files changed, 80 insertions(+), 28 deletions(-)

diff --git a/compose.c b/compose.c
index bba75a43..f3fa44b0 100644
--- a/compose.c
+++ b/compose.c
@@ -342,7 +342,8 @@ static void redraw_crypt_lines(struct ComposeRedrawData *rd)
     SET_COLOR(MT_COLOR_COMPOSE_HEADER);
     printw("%*s", HeaderPadding[HDR_CRYPTINFO], _(Prompts[HDR_CRYPTINFO]));
     NORMAL_COLOR;
-    printw("%s", sctx->pgp_sign_as ? sctx->pgp_sign_as : _("<default>"));
+    printw("%s", sctx->pgp_sign_as ? sctx->pgp_sign_as :
+           (C_PgpSignAs ? C_PgpSignAs : _("<default>")));
   }
 
   if ((WithCrypto & APPLICATION_SMIME)
@@ -351,18 +352,19 @@ static void redraw_crypt_lines(struct ComposeRedrawData *rd)
     SET_COLOR(MT_COLOR_COMPOSE_HEADER);
     printw("%*s", HeaderPadding[HDR_CRYPTINFO], _(Prompts[HDR_CRYPTINFO]));
     NORMAL_COLOR;
-    printw("%s", sctx->smime_default_key ? sctx->smime_default_key : _("<default>"));
+    printw("%s", sctx->smime_default_key ? sctx->smime_default_key :
+           (C_SmimeSignAs ? C_SmimeSignAs : _("<default>")));
   }
 
   if ((WithCrypto & APPLICATION_SMIME)
       && (msg->security & APPLICATION_SMIME)
       && (msg->security & ENCRYPT)
-      && sctx->smime_crypt_alg)
+      && (SmimeEncryptWith || sctx->smime_crypt_alg))
   {
     SET_COLOR(MT_COLOR_COMPOSE_HEADER);
     mutt_window_mvprintw(MuttIndexWindow, HDR_CRYPTINFO, 40, "%s", _("Encrypt with: "));
     NORMAL_COLOR;
-    printw("%s", NONULL(sctx->smime_crypt_alg));
+    printw("%s", sctx->smime_crypt_alg ? sctx->smime_crypt_alg : SmimeEncryptWith );
   }
 
 #ifdef USE_AUTOCRYPT
diff --git a/ncrypt/crypt.c b/ncrypt/crypt.c
index 87cf2534..b7304c46 100644
--- a/ncrypt/crypt.c
+++ b/ncrypt/crypt.c
@@ -128,18 +128,24 @@ int crypt_valid_passphrase(int flags)
 
 
 /* In postpone mode, signing is automatically disabled. */
-int mutt_protect(struct Email *msg, char *keylist, int postpone)
+int mutt_protect(SEND_CONTEXT *sctx, char *keylist, int postpone)
 {
+  struct Email *msg;
   struct Body *pbody = NULL, *tmp_pbody = NULL;
   struct Body *tmp_smime_pbody = NULL;
   struct Body *tmp_pgp_pbody = NULL;
   struct Envelope *protected_headers = NULL;
   int security, sign, has_retainable_sig = 0;
-  int i;
+  int i, rc = -1;
+  char *orig_pgp_sign_as = NULL,
+    *orig_smime_sign_as = NULL,
+    *orig_smime_crypt_alg = NULL;
 
   if (!WithCrypto)
     return -1;
 
+  msg = sctx->msg;
+
   security = msg->security;
   sign = security & (AUTOCRYPT | SIGN);
   if (postpone)
@@ -156,6 +162,26 @@ int mutt_protect(struct Email *msg, char *keylist, int postpone)
       !crypt_valid_passphrase(security))
     return (-1);
 
+  /* Override with sctx settings, if they are set.
+   * This can happen with the compose send_menus and when resuming a
+   * postponed message.
+   */
+  if (sctx->pgp_sign_as)
+  {
+    orig_pgp_sign_as = mutt_str_strdup(C_PgpSignAs);
+    mutt_str_replace(&C_PgpSignAs, sctx->pgp_sign_as);
+  }
+  if (sctx->smime_default_key)
+  {
+    orig_smime_sign_as = mutt_str_strdup(C_SmimeSignAs);
+    mutt_str_replace(&C_SmimeSignAs, sctx->smime_default_key);
+  }
+  if (sctx->smime_crypt_alg)
+  {
+    orig_smime_crypt_alg = mutt_str_strdup(SmimeEncryptWith);
+    mutt_str_replace(&SmimeEncryptWith, sctx->smime_crypt_alg);
+  }
+
   if ((WithCrypto & APPLICATION_PGP) &&
       !(security & AUTOCRYPT) &&
      ((security & PGP_INLINE) == PGP_INLINE))
@@ -167,7 +193,7 @@ int mutt_protect(struct Email *msg, char *keylist, int postpone)
               _("Inline PGP can't be used with attachments.  Revert to PGP/MIME?"))) != MUTT_YES)
       {
         mutt_error _("Mail not sent: inline PGP can't be used with attachments.");
-        return -1;
+        goto cleanup;
       }
     }
     else if (!mutt_str_strcasecmp("flowed",
@@ -177,7 +203,7 @@ int mutt_protect(struct Email *msg, char *keylist, int postpone)
               _("Inline PGP can't be used with format=flowed.  Revert to PGP/MIME?"))) != MUTT_YES)
       {
         mutt_error _("Mail not sent: inline PGP can't be used with format=flowed.");
-        return -1;
+        goto cleanup;
       }
     }
     else
@@ -188,14 +214,15 @@ int mutt_protect(struct Email *msg, char *keylist, int postpone)
       if (pbody)
       {
         msg->content = pbody;
-        return 0;
+        rc = 0;
+        goto cleanup;
       }
 
       /* otherwise inline won't work...ask for revert */
       if ((i = query_quadoption(C_PgpMimeAuto, _("Message can't be sent inline.  Revert to using PGP/MIME?"))) != MUTT_YES)
       {
         mutt_error _("Mail not sent.");
-        return -1;
+        goto cleanup;
       }
     }
 
@@ -263,7 +290,7 @@ int mutt_protect(struct Email *msg, char *keylist, int postpone)
         && (security & APPLICATION_SMIME))
     {
       if (!(tmp_pbody = crypt_smime_sign_message(msg->content)))
-        goto bail;
+        goto cleanup;
       pbody = tmp_smime_pbody = tmp_pbody;
     }
 
@@ -272,7 +299,7 @@ int mutt_protect(struct Email *msg, char *keylist, int postpone)
         && (!(security & (ENCRYPT | AUTOCRYPT)) || option(C_PgpRetainableSigs)))
     {
       if (!(tmp_pbody = crypt_pgp_sign_message(msg->content)))
-        goto bail;
+        goto cleanup;
 
       has_retainable_sig = 1;
       sign = 0;
@@ -297,7 +324,7 @@ int mutt_protect(struct Email *msg, char *keylist, int postpone)
                                                         keylist)))
       {
         /* signed ? free it! */
-        goto bail;
+        goto cleanup;
       }
       /* free tmp_body if messages was signed AND encrypted ... */
       if (tmp_smime_pbody != msg->content && tmp_smime_pbody != tmp_pbody)
@@ -327,7 +354,7 @@ int mutt_protect(struct Email *msg, char *keylist, int postpone)
           mutt_body_free(&tmp_pgp_pbody->next);
         }
 
-        goto bail;
+        goto cleanup;
       }
 
       /* destroy temporary signature envelope when doing retainable
@@ -345,12 +372,21 @@ int mutt_protect(struct Email *msg, char *keylist, int postpone)
   if (pbody)
   {
     msg->content = pbody;
-    return 0;
+    rc = 0;
   }
 
-bail:
-  mutt_env_free(&msg->content->mime_headers);
-  return -1;
+cleanup:
+  if (rc != 0)
+    mutt_env_free(&msg->content->mime_headers);
+
+  if (sctx->pgp_sign_as)
+    mutt_str_replace(&C_PgpSignAs, orig_pgp_sign_as);
+  if (sctx->smime_default_key)
+    mutt_str_replace(&C_SmimeSignAs, orig_smime_sign_as);
+  if (sctx->smime_crypt_alg)
+    mutt_str_replace(&SmimeEncryptWith, orig_smime_crypt_alg);
+
+  return rc;
 }
 
 
diff --git a/ncrypt/crypt.h b/ncrypt/crypt.h
index 8da5c06c..9511507b 100644
--- a/ncrypt/crypt.h
+++ b/ncrypt/crypt.h
@@ -111,7 +111,7 @@ typedef struct pgp_keyinfo *struct PgpKeyInfo *;
 
 /* Some prototypes -- old crypt.h. */
 
-int mutt_protect(struct Email *, char *, int);
+int mutt_protect(SEND_CONTEXT *, char *, int);
 
 int mutt_is_multipart_encrypted(struct Body *);
 
diff --git a/send.c b/send.c
index e558921c..11291231 100644
--- a/send.c
+++ b/send.c
@@ -1209,17 +1209,23 @@ cleanup:
   return (i);
 }
 
-static int save_fcc(struct Email *msg, struct Buffer *fcc,
+static int save_fcc(SEND_CONTEXT *sctx,
                      struct Body *clear_content, char *pgpkeylist,
                      int flags)
 {
+  struct Email *msg;
+  struct Buffer *fcc;
   int rc = 0;
-  struct Body *tmpbody = msg->content;
+  struct Body *tmpbody;
   struct Body *save_content = NULL;
   struct Body *save_sig = NULL;
   struct Body *save_parts = NULL;
   int choice, save_atts;
 
+  msg = sctx->msg;
+  fcc = sctx->fcc;
+  tmpbody = msg->content;
+
   mutt_buffer_expand_path(fcc);
 
   /* Don't save a copy when we are in batch-mode, and the FCC
@@ -1292,7 +1298,7 @@ static int save_fcc(struct Email *msg, struct Buffer *fcc,
           /* this means writing only the main part */
           msg->content = clear_content->parts;
 
-          if (mutt_protect(msg, pgpkeylist, 0) == -1)
+          if (mutt_protect(sctx, pgpkeylist, 0) == -1)
           {
             /* we can't do much about it at this point, so
              * fallback to saving the whole thing to fcc
@@ -1514,8 +1520,11 @@ static int has_attach_keyword(char *filename)
   return match;
 }
 
-static int postpone_message(struct Email *msg, struct Email *cur, const char *fcc, int flags)
+static int postpone_message(SEND_CONTEXT *sctx)
 {
+  struct Email *msg, *cur;
+  const char *fcc;
+  int flags;
   char *pgpkeylist = NULL;
   char *encrypt_as = NULL;
   struct Body *clear_content = NULL;
@@ -1526,6 +1535,11 @@ static int postpone_message(struct Email *msg, struct Email *cur, const char *fcc, int flag
     return -1;
   }
 
+  msg = sctx->msg;
+  cur = sctx->cur;
+  fcc = mutt_b2s(sctx->fcc);
+  flags = sctx->flags;
+
   if (msg->content->next)
     msg->content = mutt_make_multipart_mixed(msg->content);
 
@@ -1558,7 +1572,7 @@ static int postpone_message(struct Email *msg, struct Email *cur, const char *fcc, int flag
     {
       pgpkeylist = mutt_str_strdup(encrypt_as);
       clear_content = msg->content;
-      if (mutt_protect(msg, pgpkeylist, 1) == -1)
+      if (mutt_protect(sctx, pgpkeylist, 1) == -1)
       {
         FREE(&pgpkeylist);
         msg->content = mutt_remove_multipart_mixed(msg->content);
@@ -2134,7 +2148,7 @@ main_loop:
     }
     else if (i == 1)
     {
-      if (postpone_message(sctx->msg, sctx->cur, mutt_b2s(sctx->fcc), sctx->flags) != 0)
+      if (postpone_message(sctx) != 0)
         goto main_loop;
       mutt_message _("Message postponed.");
       rv = 1;
@@ -2231,7 +2245,7 @@ main_loop:
       clear_content = sctx->msg->content;
 
       if ((crypt_get_keys(sctx->msg, &pgpkeylist, 0) == -1) ||
-          mutt_protect(sctx->msg, pgpkeylist, 0) == -1)
+          mutt_protect(sctx, pgpkeylist, 0) == -1)
       {
         sctx->msg->content = mutt_remove_multipart_mixed(sctx->msg->content);
         sctx->msg->content = mutt_remove_multipart_alternative(sctx->msg->content);
@@ -2266,7 +2280,7 @@ main_loop:
   mutt_prepare_envelope(sctx->msg->env, 1);
 
   if (option(C_FccBeforeSend))
-    save_fcc(sctx->msg, sctx->fcc, clear_content, pgpkeylist, sctx->flags);
+    save_fcc(sctx, clear_content, pgpkeylist, sctx->flags);
 
   if ((i = invoke_mta(sctx->msg)) < 0)
   {
@@ -2305,7 +2319,7 @@ main_loop:
   }
 
   if (!option(C_FccBeforeSend))
-    save_fcc(sctx->msg, sctx->fcc, clear_content, pgpkeylist, sctx->flags);
+    save_fcc(sctx, clear_content, pgpkeylist, sctx->flags);
 
   if (!option(OptNoCurses) && !(sctx->flags & SEND_MAILX))
   {
