From 83be183b55a41b2ffb84177e8ce4e271fea67b00 Mon Sep 17 00:00:00 2001
From: Kevin McCarthy <kevin@8t8.us>
Date: Sat, 8 Feb 2020 19:16:33 -0800
Subject: Fix ~v tagging when switching to non-threaded sorting

Place num_hidden in all the collapsed thread messages, rather than
just the visible ones(i.e. the root headers).

This is a tweak to commit 0f8a079d, where I discovered the behavior
inconsistent with the documentation.  I'm making this change in master
due to the(tiny) behavior change.

Upstream-commit: https://gitlab.com/muttmua/mutt/commit/83be183b55a41b2ffb84177e8ce4e271fea67b00
Co-authored-by: Richard Russon <rich@flatcap.org>
---
 email/thread.c | 43 +++++++++++++++++++++++++++++++++++++------
 1 file changed, 37 insertions(+), 6 deletions(-)

diff --git a/email/thread.c b/email/thread.c
index 9680108f..fc6c3cb8 100644
--- a/email/thread.c
+++ b/email/thread.c
@@ -1194,8 +1194,7 @@ int _mutt_traverse_thread(struct Context *ctx, struct Email *cur, int flag)
     /* return value depends on action requested */
     if (flag & (MUTT_THREAD_COLLAPSE | MUTT_THREAD_UNCOLLAPSE))
     {
-      if (roothdr)
-        roothdr->num_hidden = num_hidden;
+      cur->num_hidden = num_hidden;
       return (final);
     }
     else if (flag & MUTT_THREAD_UNREAD)
@@ -1279,13 +1278,45 @@ int _mutt_traverse_thread(struct Context *ctx, struct Email *cur, int flag)
     }
   }
 
+  /* retraverse the thread and store num_hidden in all headers, with
+   * or without a virtual index.  this will allow ~v to match all
+   * collapsed messages when switching sort order to non-threaded.
+   */
+  if (flag & MUTT_THREAD_COLLAPSE)
+  {
+    thread = top;
+    FOREVER
+    {
+      cur = thread->message;
+      if (cur)
+        cur->num_hidden = num_hidden + 1;
+
+      if (thread->child)
+        thread = thread->child;
+      else if (thread->next)
+        thread = thread->next;
+      else
+      {
+        int done = 0;
+        while (!thread->next)
+        {
+          thread = thread->parent;
+          if (thread == top)
+          {
+            done = 1;
+            break;
+          }
+        }
+        if (done)
+          break;
+        thread = thread->next;
+      }
+    }
+  }
+
   /* return value depends on action requested */
   if (flag & (MUTT_THREAD_COLLAPSE | MUTT_THREAD_UNCOLLAPSE))
-  {
-    if (roothdr)
-      roothdr->num_hidden = num_hidden + 1;
     return (final);
-  }
   else if (flag & MUTT_THREAD_UNREAD)
     return ((old && new) ? new :(old ? old : new));
   else if (flag & MUTT_THREAD_NEXT_UNREAD)
