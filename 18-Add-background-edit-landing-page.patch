From 0d66dd5fcabdbdea8dbe20c1b3078b040b11d832 Mon Sep 17 00:00:00 2001
From: Kevin McCarthy <kevin@8t8.us>
Date: Sun, 16 Feb 2020 12:30:54 -0800
Subject: Add background edit landing page

The landing page waits for the $editor process to exit, or until the
user presses <exit>, "q" by default.  If they press exit they are
returned to the index.  If the $editor exits first, they are returned
directly to the compose process.

Upstream-commit: https://gitlab.com/muttmua/mutt/commit/0d66dd5fcabdbdea8dbe20c1b3078b040b11d832
Co-authored-by: Richard Russon <rich@flatcap.org>
---
 background.c | 120 +++++++++++++++++++++++++++++++++++++++++++++++++--
 compose.c    |   2 +-
 mutt_header.c    |   2 +-
 send.c       |   2 +-
 4 files changed, 119 insertions(+), 7 deletions(-)

diff --git a/background.c b/background.c
index aba56b00..4fa49f1b 100644
--- a/background.c
+++ b/background.c
@@ -22,6 +22,7 @@
 #endif
 
 #include "mutt.h"
+#include "mutt_menu.h"
 #include "send.h"
 #include "background.h"
 
@@ -30,6 +31,7 @@
 #include <string.h>
 #include <sys/wait.h>
 #include <unistd.h>
+#include <errno.h>
 
 
 static pid_t mutt_background_run(const char *cmd)
@@ -82,6 +84,114 @@ static pid_t mutt_background_run(const char *cmd)
   return (thepid);
 }
 
+static const struct mapping_t LandingHelp[] = {
+  { N_("Exit"),  OP_EXIT },
+  { N_("Redraw"), OP_REDRAW },
+  { N_("Help"),  OP_HELP },
+  { NULL,         0 }
+};
+
+static void landing_redraw(struct Menu *menu)
+{
+  menu_redraw(menu);
+  mutt_window_mvaddstr(MuttIndexWindow, 0, 0,
+                        _("Waiting for editor to exit"));
+  mutt_window_mvaddstr(MuttIndexWindow, 1, 0,
+                        _("Hit <exit> to background editor."));
+}
+
+/* Displays the "waiting for editor" page.
+ * Returns:
+ *   2 if the the menu is exited, leaving the process backgrounded
+ *   0 when the waitpid() indicates the process has exited
+ */
+static int background_edit_landing_page(pid_t bg_pid)
+{
+  int done = 0, rc = 0, op;
+  short orig_timeout;
+  pid_t wait_rc;
+  struct Menu *menu;
+  char helpstr[256];
+
+  menu = mutt_menu_new(MENU_GENERIC);
+  menu->help = mutt_compile_help(helpstr, sizeof(helpstr),
+                                  MENU_GENERIC, LandingHelp);
+  menu->pagelen = 0;
+  menu->title = _("Waiting for editor to exit");
+
+  mutt_menu_push_current(menu);
+
+  /* Reduce timeout so we poll with bg_pid every second */
+  orig_timeout = C_Timeout;
+  C_Timeout = 1;
+
+  while (!done)
+  {
+    wait_rc = waitpid(bg_pid, NULL, WNOHANG);
+    if ((wait_rc > 0) ||
+       ((wait_rc < 0) && (errno == ECHILD)))
+    {
+      rc = 0;
+      break;
+    }
+
+#if defined(USE_SLANG_CURSES) || defined(HAVE_RESIZETERM)
+    if (SigWinch)
+    {
+      SigWinch = 0;
+      mutt_resize_screen();
+      clearok(stdscr, TRUE);
+    }
+#endif
+
+    if (menu->redraw)
+      landing_redraw(menu);
+
+    op = km_dokey(MENU_GENERIC);
+
+    switch(op)
+    {
+      case OP_HELP:
+        mutt_help(MENU_GENERIC);
+        menu->redraw = REDRAW_FULL;
+        break;
+
+      case OP_EXIT:
+        rc = 2;
+        done = 1;
+        break;
+
+      case OP_REDRAW:
+        clearok(stdscr, TRUE);
+        menu->redraw = REDRAW_FULL;
+        break;
+    }
+  }
+
+  C_Timeout = orig_timeout;
+
+  mutt_menu_pop_current(menu);
+  mutt_menu_destroy(&menu);
+
+  return rc;
+}
+
+/* Runs editor in the background.
+ *
+ * After backgrounding the process, the background landing page will
+ * be displayed.  The user will have the opportunity to "quit" the
+ * landing page, exiting back to the index.  That will return 2
+ *(chosen for consistency with other backgrounding functions).
+ *
+ * If they leave the landing page up, it will detect when the editor finishes
+ * and return 0, indicating the callers should continue processing
+ * as if it were a foreground edit.
+ *
+ * Returns:
+ *      2  - the edit was backgrounded
+ *      0  - background edit completed.
+ *     -1  - an error occurred
+ */
 int mutt_background_edit_file(SEND_CONTEXT *sctx, const char *editor,
                                const char *filename)
 {
@@ -100,10 +210,12 @@ int mutt_background_edit_file(SEND_CONTEXT *sctx, const char *editor,
     goto cleanup;
   }
 
-  sctx->background_pid = pid;
-  BackgroundProcess = sctx;
-
-  rc = 0;
+  rc = background_edit_landing_page(pid);
+  if (rc == 2)
+  {
+    sctx->background_pid = pid;
+    BackgroundProcess = sctx;
+  }
 
 cleanup:
   mutt_buffer_pool_release(&cmd);
diff --git a/compose.c b/compose.c
index d6c7a61c..b57e17a2 100644
--- a/compose.c
+++ b/compose.c
@@ -1143,7 +1143,7 @@ int mutt_compose_menu(SEND_CONTEXT *sctx)
           if ((sctx->flags & SENDBACKGROUNDEDIT) && option(OPTBACKGROUNDEDIT))
           {
             if (mutt_background_edit_file(sctx, C_Editor,
-                                           msg->content->filename) == 0)
+                                           msg->content->filename) == 2)
             {
               sctx->state = SEND_STATE_COMPOSE_EDIT;
               loop = 0;
diff --git a/mutt_header.c b/mutt_header.c
index 3a4879d0..a8725c0f 100644
--- a/mutt_header.c
+++ b/mutt_header.c
@@ -80,7 +80,7 @@ int mutt_edit_headers(const char *editor,
 
     if (flags == MUTT_EDIT_HEADERS_BACKGROUND)
     {
-      if (mutt_background_edit_file(sctx, editor, mutt_b2s(sctx->tempfile)) == 0)
+      if (mutt_background_edit_file(sctx, editor, mutt_b2s(sctx->tempfile)) == 2)
       {
         sctx->state = SEND_STATE_FIRST_EDIT_HEADERS;
         return 2;
diff --git a/send.c b/send.c
index 39d40093..061e7c50 100644
--- a/send.c
+++ b/send.c
@@ -2004,7 +2004,7 @@ static int send_message_resume_first_edit(SEND_CONTEXT *sctx)
           if (background_edit)
           {
             if (mutt_background_edit_file(sctx, C_Editor,
-                                           sctx->msg->content->filename) == 0)
+                                           sctx->msg->content->filename) == 2)
             {
               sctx->state = SEND_STATE_FIRST_EDIT;
               return 2;
